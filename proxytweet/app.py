import os
import html
import re
import logging
from twitterscraper.query import query_tweets_from_user
import rfeed as rf
from flask import Flask, Response, render_template, redirect, request
from functools import reduce
from bs4 import BeautifulSoup


class DefaultSettings(object):
    DEBUG = False
    TESTING = False
    SECRET_KEY = b"\x15C3v\x01E\xf7\x97\xda\x10\x8f\x89W\x90\xefr"
    SERVER_NAME = "127.0.0.1:5052"
    TWEET_LIMIT = 100


class TwitterFeed(rf.Extension):
    def get_namespace(self):
        return {
            "xmlns:atom": "http://www.w3.org/2005/Atom",
            "xmlns:georss": "http://www.georss.org/georss",
            "xmlns:twitter": "http://api.twitter.com",
            "xmlns:dc": "http://purl.org/dc/elements/1.1/",
        }

    def publish(self, handler):
        rf.Serializable.publish(self, handler)
        self._write_element(
            "atom:link",
            None,
            attributes={
                "href": "http://192.168.11.130:5000",
                "rel": "self",
                "type": "application/rss+xml",
            },
        )


class TwitterItem(rf.Serializable):
    def __init__(self):
        rf.Serializable.__init__(self)

    def publish(self, handler):
        rf.Serializable.publish(self, handler)
        self._write_short_element("twitter:source")
        self._write_short_element("twitter:place")

    def _write_short_element(self, name):
        self.handler.startElement(name, {})
        self.handler.endElement(name)


def get_user_tweets(user, limit):
    return query_tweets_from_user(user, limit=limit)


def format_cdata(content):
    return "<![CDATA[{0}]]>".format(content)


def format_description(html):
    content = reduce(
        lambda s, r: re.sub(*r, s),
        [
            ("</?s>", ""),  # remove strikethroughs
            ("(#|@)<b>", "<b>\\1"),  # make tags entirely bold
            ("</?span[^>]*>", ""),  # remove spans
            ('data-[\\w\\-]+="[^"]+"', ""),  # remove data-* attributes
            ('target="_blank"', ""),  # remove link targets
        ],
        html,
    )
    return format_cdata(content)


def format_title(html):
    # just remove the links and return contents of the text
    return format_cdata(BeautifulSoup(html).p.contents[0])


def format_tweet(tweet, user):
    ln = "https://twitter.com/{0}/status/{1}".format(user, tweet.id)
    return rf.Item(
        title=format_title(tweet.text),
        description=format_description(tweet.html),
        creator="@{0}".format(user),
        link=ln,
        guid=rf.Guid(ln),
        pubDate=tweet.timestamp,
        extensions=[TwitterItem()],
    )


def tweets_to_rss(user, limit):
    return rf.Feed(
        title="Tweets from @{0}".format(user),
        description="Tweets from @{0}, generated by ProxyTweet".format(user),
        link="https://twitter.com/{0}".format(user),
        language="en-us",
        ttl=15,
        items=[format_tweet(t, user) for t in get_user_tweets(user, limit)],
        extensions=[TwitterFeed()],
    )


logging.getLogger("twitterscraper").setLevel("ERROR")


def main():
    app = Flask(__name__)

    app.config.from_object("proxytweet.app:DefaultSettings")
    conf_env = "PROXYTWEET_CONF"
    if os.getenv(conf_env):
        app.config.from_envvar(conf_env)

    @app.route("/")
    def index():
        return render_template("index.html")

    @app.route("/user/<handle>")
    def user(handle):
        limit = app.config["TWEET_LIMIT"]
        rss = html.unescape(tweets_to_rss(handle, limit).rss())
        return Response(rss, mimetype="application/rss+xml")

    @app.route("/user", methods=["POST"])
    def user_post():
        user_url = "/user/" + request.form["user"]
        return redirect(user_url)

    app.run()
